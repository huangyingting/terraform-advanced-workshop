name: 'Terraform Deploy'

on:
  push:
    branches: [main]
    paths:
      - '**.tf'
      - '**.tfvars'
      - '.github/workflows/apply.yml'
      - '.github/workflows/plan.yml'

# Allow only one concurrent deployment
concurrency:
  group: terraform-deploy
  cancel-in-progress: false

permissions:
  id-token: write
  contents: read
  actions: read

env:
  TF_VERSION: '1.7.5'
  TF_IN_AUTOMATION: true
  TF_INPUT: false

jobs:
  deploy-staging:
    name: 'Deploy to Staging'
    runs-on: ubuntu-latest
    environment: staging
    
    outputs:
      deployment-status: ${{ steps.apply.outcome }}
      resource-summary: ${{ steps.output.outputs.summary }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login via OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Copy Backend Configuration
        run: |
          cp environments/staging/backend.tf .
          echo "Backend configuration for staging:"
          cat backend.tf

      - name: Terraform Init
        run: terraform init
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan \
            -var-file="staging.tfvars" \
            -out="staging.tfplan" \
            -detailed-exitcode
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Apply
        id: apply
        run: terraform apply -auto-approve staging.tfplan
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Output
        id: output
        run: |
          terraform output -json > staging_outputs.json
          echo "summary=$(terraform output -json resource_summary | jq -c .)" >> $GITHUB_OUTPUT

      - name: Upload Deployment Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: staging-deployment
          path: |
            staging_outputs.json
            terraform.tfstate
          retention-days: 30

      - name: Test Staging Deployment
        run: |
          VM_IP=$(terraform output -raw vm_public_ip)
          echo "Testing staging deployment at IP: $VM_IP"
          
          # Wait for VM to be ready
          echo "Waiting for VM to be ready..."
          for i in {1..30}; do
            if curl -s -o /dev/null -w "%{http_code}" http://$VM_IP/ | grep -q "200"; then
              echo "‚úÖ Staging deployment is healthy"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 10
          done

  deploy-production:
    name: 'Deploy to Production'
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment: production
    if: needs.deploy-staging.outputs.deployment-status == 'success'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login via OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Copy Backend Configuration
        run: |
          cp environments/production/backend.tf .
          echo "Backend configuration for production:"
          cat backend.tf

      - name: Terraform Init
        run: terraform init
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan \
            -var-file="production.tfvars" \
            -out="production.tfplan" \
            -detailed-exitcode
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Apply
        id: apply
        run: terraform apply -auto-approve production.tfplan
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Output
        id: output
        run: |
          terraform output -json > production_outputs.json
          echo "üéâ Production deployment completed successfully!"
          echo "VM Public IP: $(terraform output -raw vm_public_ip)"
          echo "SSH Command: $(terraform output -raw ssh_connection_command)"

      - name: Upload Deployment Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: production-deployment
          path: |
            production_outputs.json
            terraform.tfstate
          retention-days: 90

      - name: Test Production Deployment
        run: |
          VM_IP=$(terraform output -raw vm_public_ip)
          echo "Testing production deployment at IP: $VM_IP"
          
          # Wait for VM to be ready
          echo "Waiting for VM to be ready..."
          for i in {1..30}; do
            if curl -s -o /dev/null -w "%{http_code}" http://$VM_IP/ | grep -q "200"; then
              echo "‚úÖ Production deployment is healthy"
              echo "üåê Application URL: http://$VM_IP/"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 10
          done

      - name: Post Deployment Summary
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read production outputs
            const outputs = JSON.parse(fs.readFileSync('production_outputs.json', 'utf8'));
            
            const summary = `
            ## üöÄ Production Deployment Successful
            
            **Deployment Time:** ${new Date().toISOString()}
            **Commit:** ${{ github.sha }}
            **Environment:** Production
            
            ### üìä Deployed Resources
            ${JSON.stringify(outputs.resource_summary.value, null, 2)}
            
            ### üîó Access Information
            - **Application URL:** http://${outputs.vm_public_ip.value}/
            - **SSH Access:** \`${outputs.ssh_connection_command.value}\`
            - **Resource Group:** ${outputs.resource_group_name.value}
            
            ### ‚úÖ Post-Deployment Checks
            - [x] Infrastructure deployed successfully
            - [x] Application health check passed
            - [x] Resources accessible
            
            ---
            *Deployed via GitHub Actions*
            `;
            
            console.log(summary);
